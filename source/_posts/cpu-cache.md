title: CPU缓存L1和L2
date: 2016-02-27 18:36:12
tags:
- cpu
- L1cache
- L2cache
categories:
- linux
toc: true

---

上篇文章分析了CPU如何向内存请求数据，我们也知道cpu请求的数据是先放到L1和L2缓存中，那么这篇文章来分析下cpu内部是如何组织访问缓存的．本科计算机体系结构课上有学过缓存的三种方式，全相连，直接相连，组相连．组相连是全相连和直接相连的折中，了解了组相连，其他两个也就很好理解了．这个博客分析的是36位地址总线，虽然现在是32位地址总线，但是不影响分析．

我还是以大神[Gustavo Duarte](http://duartes.org/gustavo/blog/post/intel-cpu-caches/ "")为基础，再加上一些自己的想法来写这篇文章．我们先上图:
![8路组相连](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_061.png "")
l1 cache有32kb，８路组相连，总共有64行(64组)，每个缓存行为64byte．当cpu给出一个虚拟地址，然后经过TLB或者MMU转换成物理地址之后，
1. 其中的12-35位为物理页的标签，已4kb对齐，也就是以内存页对齐，那么24位总共有2^24个物理页，而每个物理页是4kb，所以总的物理内存为2^36=64G.
2. 其中的11-6位的组索引，6位对应着64组．
3. 最低6位为缓存行内寻址．每个缓存行为64b，所以需要6位进行寻址

由图可知，每一路为64*6b=4kb，总共有８路，所有L1 cache有32kb总量．

当cpu给出一个逻辑地址，然后经过TLB或者MMU转换为物理地址之后，我们先通过组索引找到数据在哪一组；然后将给组的所有缓存行的标识位取出来和地址中的标志为比较，如果没有命中，则需要到主存中获取一块64字节的缓存行，存入L1中；如果命中，则通过最低6位定位缓存行中具体字节．如下图所示:
![cache命中](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_062.png "")

而L2 cache缓存有4M，所以就不能和L1 cache缓存一样组织．在L2缓存中，缓存行的大小还是64b，但将组数增加到4096，然后路数增加到16路，这样以来，每一组就有16\*64=1024b=1kb，总共有4096组，所以L2 cache有1kb*4096=4096kb=4M．

理解了组相连之后，我们先说下直接映射．对与直接映射，其实就是组相连的特例，将每一组的路数设为1，即1路组相连．这样当有相同的页映射到同一块缓存行时，之前缓存的数据必须被提出；而８路组相连可以缓存映射到同一组的8个缓存行，这样缓存行在缓存的时间会更长，更能利用局部性原理．
![三种缓存映射方式](http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_063.png "")

而全相连也是组相连的一种特例，即只有一组，然后这组有n路．这样一来，只要缓存有空间，任何安页对齐的64字节主存块都可以存储到缓存中．这样每次查找时，都要遍历所有的缓存行，一一匹配．






























